# Memory Management in Operating Systems

## 1. Logical vs Physical Address Space
- **Logical Address (Virtual):** Generated by the CPU when a process executes. It represents the program’s own view of memory.  
- **Physical Address:** The actual location in RAM.  
- The **Memory Management Unit (MMU)** converts logical to physical addresses at runtime, enabling process isolation and protection.

| Aspect | Logical Address | Physical Address |
|---------|-----------------|------------------|
| Generated by | CPU | MMU |
| Seen by | User / Program | Hardware |
| Purpose | Abstraction for processes | Actual data storage |

This allows multiple processes to share memory safely without interfering.

## 2. Swapping
Swapping temporarily moves whole processes between **main memory** and **secondary storage (disk)** to free up RAM.

**Steps:**
1. Idle or waiting processes are swapped out to disk.
2. When needed again, they are swapped back into RAM.

**Pros:** Increases degree of multiprogramming.  
**Cons:** Disk I/O is slow; excessive swapping causes **thrashing**.

## 3. Contiguous Memory Allocation
Each process is given a **single continuous block** of physical memory.

### Partitioning
- **Fixed Partitioning:** Memory divided into equal parts; wastes space (internal fragmentation).
- **Dynamic Partitioning:** Allocates exactly what process needs; may cause external fragmentation.

### Holes
Free memory blocks between allocated partitions are called **holes**. They can be used by new processes depending on allocation strategy.

### Allocation Strategies
| Strategy | Description | Advantage | Disadvantage |
|-----------|--------------|------------|---------------|
| **First Fit** | Allocate the first hole large enough | Fast | May leave many small holes |
| **Best Fit** | Allocate the smallest hole that fits | Minimizes wasted space | Slow, causes small unusable holes |
| **Worst Fit** | Allocate the largest hole available | Leaves large free areas | Poor overall utilization |

### Fragmentation
- **Internal Fragmentation:** Wasted space inside allocated block.  
- **External Fragmentation:** Free space scattered between blocks.

### Compaction
A process of **moving allocated blocks** together and **merging holes** to form one large free space. Used to reduce **external fragmentation**.

## 4. Paging
Paging divides memory into **fixed-size blocks**:
- **Pages:** Blocks in logical (virtual) memory.
- **Frames:** Blocks in physical memory.

When a process loads, its pages are placed in any available frames (non-contiguous).

**Address Translation:** Done by the **Page Table**, mapping each page number to a frame number.

| Term | Description |
|-------|--------------|
| Page | Logical block of memory (fixed size) |
| Frame | Physical block of RAM (same size as page) |
| Page Table | Maps page → frame |
| TLB | Cache that stores recent page translations |

**Advantages:**
- No external fragmentation.
- Efficient use of RAM.

**Disadvantages:**
- May have internal fragmentation (unused space in frames).
- Requires page table management.

## 5. Segmentation

In segmentation, each segment occupies a contiguous block of physical memory, but segments themselves can be scattered across RAM. The compiler define and manage segments such as code, data, and stack. Each segment is an independent logical unit, unlike paging, which divides memory into equal-sized pages purely for storage management.

Memory divided into **variable-sized segments** that represent logical program units such as:
- Code
- Stack
- Heap
- Data

Each segment has a **Segment Number** and **Offset**.  
The **Segment Table** stores the base and limit (size) of each segment.

**Advantages:**
- Matches program structure.
- Allows sharing and protection.

**Disadvantages:**
- Causes external fragmentation.
- Harder to manage due to varying segment sizes.

## 6. Segmentation with Paging
A hybrid scheme combining segmentation and paging.
1. The program is divided into **segments**.
2. Each segment is divided into **pages**.
3. Pages are mapped to physical **frames**.

Address format: **Segment Number + Page Number + Offset**.

**Advantages:**
- Logical view from segmentation.
- No external fragmentation due to paging.
- Easier protection and sharing.

**Disadvantages:**
- More complex address translation (two-level lookup).

## 7. Comparison Summary

| Concept | Description | Fragmentation Type | Contiguous Allocation | Key Structure |
|----------|--------------|--------------------|------------------------|----------------|
| **Contiguous Allocation** | Single continuous block | External & Internal | Yes | Base + Limit |
| **Paging** | Fixed-size pages and frames | Internal | No | Page Table |
| **Segmentation** | Variable-sized logical segments | External | No | Segment Table |
| **Segmentation with Paging** | Segments divided into pages | Minimal | No | Segment + Page Tables |
| **Fragmentation** | Unused memory (internal/external) | — | — | — |
| **Pagination** | Process of dividing memory into pages | — | — | — |
| **Compaction** | Rearranging memory to reduce holes | Fixes external frag. | Yes | — |

### Summary
- **Fragmentation** is wasted memory space (internal or external).  
- **Pagination (Paging)** eliminates external fragmentation using fixed-size blocks.  
- **Compaction** rearranges memory to merge holes and improve utilization.  
- **Segmentation** provides logical division but may cause fragmentation.  
- **Segmentation with Paging** combines both for efficient, flexible memory management.
